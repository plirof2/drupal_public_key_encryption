<?php
/**
 * @file
 * Main module file for the Webform Encrypt module.
 */


// NOTE********* get private-public keys from SOURCE of html (or using <pre></pre>)
/**
 * Implementation of hook_permission().
 */
function webform_encrypt_permission() {
  return array(
    'view encrypted values' => array(
      'title' => t('View Encrypted Values in Webform Results'),
      'description' => t('Users that do not have this permission will see placeholder text.'),
    ),
  );
}

/**
 * Implementation of hook_form_FORM_ID_alter().
 */
function webform_encrypt_form_webform_admin_settings_alter(&$form, $form_state) {
  // Add our config options to the webform settings page.
  $form['encrypt'] = array(
    '#type' => 'fieldset',
    '#title' => t('Webform Encrypt'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );
  $form['encrypt']['webform_encrypt_match_user'] = array(
    '#type' => 'checkbox',
    '#title' => t('Enable email to user matching'),
    '#description' => t('If enabled, every time webform sends an email, it will attempt to find a user that matches the email address the mail will be sent to in order to correctly determine permissions.'),
    '#default_value' => variable_get('webform_encrypt_match_user', 0),
  );
}

/**
 * Implementation of hook_form_FORM_ID_alter().
 */
function webform_encrypt_form_webform_component_edit_form_alter(&$form, $form_state) {
  // Add our fields to the component add/edit form.
  $component = $form_state['build_info']['args'][1];

  // Exclude webform component types that don't make sense to encrypt.
  $excluded_types = array('fieldset', 'file', 'markup', 'pagebreak');
  if (!in_array($form['type']['#value'], $excluded_types)) {

    // Add settings for encryption.
    $form['encryption'] = array(
      '#type' => 'fieldset',
      '#title' => t('Encryption'),
      '#tree' => TRUE,
    );
    $form['encryption']['encrypt'] = array(
      '#type' => 'checkbox',
      '#title' => t('Encrypt this field\'s value'),
      '#description' => t('!link to edit encryption settings.', array('!link' => l('Click here', 'admin/config/system/encrypt'))),
      '#default_value' => isset($component['extra']['encrypt']) ? $component['extra']['encrypt'] : 0,
    );
  }
}

/**
 * Implementation of hook_webform_component_presave().
 * Save encryption settings for a component.
 */
function webform_encrypt_webform_component_presave(&$component) {
  if (!empty($component['encryption'])) {
    $component['extra'] = array_merge($component['extra'], $component['encryption']);
    unset($component['encryption']);
    
    if ($component['extra']['encrypt']) {
      webform_encrypt_encrypt_component_data($component['nid'], $component['cid'], $component['extra']);
    }
    else {
      webform_encrypt_decrypt_component_data($component['nid'], $component['cid'], $component['extra']);
    }
  }
}

/**
 * Implementation of hook_webform_submission_presave().
 * Encrypt the value if the component has been marked as such.
 */
function webform_encrypt_webform_submission_presave($node, &$submission) {
  foreach ($submission->data as $cid => $entry) {
    if (!empty($node->webform['components'][$cid]['extra']['encrypt'])) {
      foreach ($submission->data[$cid] as $delta => $value) {
        //$submission->data[$cid][$delta] = my_encrypt($entry[$delta], array('base64' => TRUE));
        $submission->data[$cid][$delta] = my_encrypt($entry[$delta], get_my_public_Key());
      }
    }
  }
}

/**
 * Implementation of hook_webform_submission_load().
 * Decrypt values if encrypted
 */
function webform_encrypt_webform_submission_load($submissions) {
  foreach ($submissions as $submission) {
    $node = node_load($submission->nid);
    foreach ($submission->data as $cid => $entry) {
      if (!empty($node->webform['components'][$cid]['extra']['encrypt'])) {
        foreach ($submission->data[$cid] as $delta => $value) {
          if (!empty($entry[$delta]) && @unserialize($entry[$delta]) !== FALSE) {
            ///$submission->data[$cid][$delta] = user_access('view encrypted values') ? my_decrypt($entry[$delta], get_my_private_Key()) : t('[Value Encrypted]');
            $submission->data[$cid][$delta] = "DEBUGGGGGGGGGGGGGGGG";//my_decrypt($entry[$delta], get_my_private_Key()) : t('[Value Encrypted]');
          }
        }
      }
    }
  }
}

/**
 * Preprocess for theme('webform_results_table').
 *
 * Decrypt webform values in the table display.
 */
function webform_encrypt_preprocess_webform_results_table(&$vars) {
  foreach ($vars['submissions'] as $sid => &$submission) {
    foreach ($submission->data as $cid => &$item) {
      $component = $vars['components'][$cid];
      if (!empty($component['extra']['encrypt'])) {
        foreach ($item['value'] as &$value) {
          //$value = user_access('view encrypted values') ? my_decrypt($value, array('base64' => TRUE)) : t('[Value Encrypted]');
          $value = user_access('view encrypted values') ? my_decrypt($value, get_my_private_Key()) : t('[Value Encrypted]');
          //$value = my_decrypt($value, get_my_private_Key());
          $value="DEBUGGGGGGGGGGGGGGGG";
          echo "DEBUGGGGGGGGGGGGGGGG";
        }
      }
    }
  }
}

/**
 * Encrypt all non-encrypted data of a component.
 */
function webform_encrypt_encrypt_component_data($nid = NULL, $cid = NULL, $extra = array()) {
  $results = db_query('SELECT nid, cid, extra FROM {webform_component} where nid = :nid AND cid = :cid', array(':nid' => $nid, ':cid' => $cid))->fetchAll();
  
  foreach ($results as $row) {
    $components[$row->nid . ':' . $row->cid] = unserialize($row->extra);
  }
  $data = db_query('SELECT nid, sid, cid, data FROM {webform_submitted_data} where nid = :nid AND cid = :cid', array(':nid' => $nid, ':cid' => $cid))->fetchAll();
  foreach ($data as $row) {
    $key = $row->nid . ':' . $row->cid;
    if (isset($components[$key]['encrypt']) && !$components[$key]['encrypt']) {
      db_update('webform_submitted_data')
        ->fields(array(
          //'data' => my_encrypt($row->data, array('base64' => TRUE)),
          //'data' => $row->data."AAA",  //ok
          'data' => my_encrypt($row->data, get_my_public_Key()),
        ))
        ->condition('nid', $row->nid)
        ->condition('sid', $row->sid)
        ->condition('cid', $row->cid)
        ->execute();
    }
  }
}

/**
 * Decrypt all encrypted data of a component.
 */
function webform_encrypt_decrypt_component_data($nid = NULL, $cid = NULL, $extra = array()) {
  $results = db_query('SELECT nid, cid, extra FROM {webform_component} where nid = :nid AND cid = :cid', array(':nid' => $nid, ':cid' => $cid))->fetchAll();
  
  foreach ($results as $row) {
    $components[$row->nid . ':' . $row->cid] = unserialize($row->extra);
  }
  $data = db_query('SELECT nid, sid, cid, data FROM {webform_submitted_data} where nid = :nid AND cid = :cid', array(':nid' => $nid, ':cid' => $cid))->fetchAll();
  foreach ($data as $row) {
    $key = $row->nid . ':' . $row->cid;
    
    if (!empty($components[$key]['encrypt']) && is_array(@unserialize($row->data))) {
      //echo "<pre>";print_R(decrypt($row->data, array('base64' => TRUE)));exit;
      db_update('webform_submitted_data')
        ->fields(array(
          //'data' => my_decrypt($row->data, array('base64' => TRUE)),
          'data' => my_decrypt($row->data, get_my_private_Key()),
        ))
        ->condition('nid', $row->nid)
        ->condition('sid', $row->sid)
        ->condition('cid', $row->cid)
        ->execute();
    }
  }
}


//--------------------------------------
// Encrypt data using the public key
function my_encrypt($data="aaa", $publicKey)
{
    // Encrypt the data using the public key
   openssl_public_encrypt($data, $encryptedData, $publicKey);
  //$encryptedData=ssl_encrypt($data,'public',get_my_public_Key());
//echo  "<HR>publicKey= $publicKey";
    // Return encrypted data
    return base64_encode($encryptedData);
}

// Decrypt data using the private key
function my_decrypt($data, $privateKey)
{
  drupal_set_message("hellooooooooooooo");
    // Decrypt the data using the private key
   openssl_private_decrypt(base64_decode($data), $decryptedData, $privateKey);
//   echo  "<HR>privateKey = $privateKey";
$decryptedData="AAAAAAAAAAAAAAAAAAA";
    // Return decrypted data
    return ($decryptedData);
}
/*
function ssl_encrypt($source,$type,$key){
//Assumes 1024 bit key and encrypts in chunks.

$maxlength=117;
$output='';
while($source){
  $input= substr($source,0,$maxlength);
  $source=substr($source,$maxlength);
  if($type=='private'){
    $ok= openssl_private_encrypt($input,$encrypted,$key);
  }else{
    $ok= openssl_public_encrypt($input,$encrypted,$key);
  }
        
  $output.=$encrypted;
}
return $output;
}

function ssl_decrypt($source,$type,$key){
// The raw PHP decryption functions appear to work
// on 128 Byte chunks. So this decrypts long text
// encrypted with ssl_encrypt().

$maxlength=128;
$output='';
while($source){
  $input= substr($source,0,$maxlength);
  $source=substr($source,$maxlength);
  if($type=='private'){
    $ok= openssl_private_decrypt($input,$out,$key);
  }else{
    $ok= openssl_public_decrypt($input,$out,$key);
  }
        
  $output.=$out;
}
return $output;

}
*/

function get_my_private_Key()
{
$private_my_key= trim('-----BEGIN PRIVATE KEY-----
MIICeAIBADANBgkqhkiG9w0BAQEFAASCAmIwggJeAgEAAoGBAO1fbkPItttNdew2
wbKP8eEtwOoJG+AJABO44VMJfXOt8RkTydZaLdwogyJ4gtK8p8ZGfmaIkj+zVLQf
8gwCEuHnOzXNLzZedU+1qjkK0m8g5h3tsooFvZTrrb5THksN688KBphg0/n/X+re
knfHeMcUSRZEdykkP/EGGGD1qH17AgMBAAECgYEAlVOPfjzqK5PTN0JLIBXFyC6M
Sa5pRsrirYWE2kQCE5+9KFV2h847Q2CI/kppokDkGquGIOKRfllGU/o0vrEfRp+N
CJsdiXCDKTjNBE5btdMmggINH/6AKz2anv4ZJEqjs0Fi//Fnk9Xnw6Uu/V0RpqKX
OAhHupum4YvRUBcPOOECQQD6BKyEHCmgO5BexEe/sUyGsJ5GLo3y7KaS2iRRy6iz
MnGnl2nn6sZ0IhWLR+RUMkGr6UrAVugc2zz80czSnQZdAkEA8w1OGMbrX6QEKhPV
2hgLI1WuS7JeTt9Gu4tFZ3qCJDsN7DGgQBXzZ4C8YfQzQRwgGBaCEyRI20XSpOPA
OJultwJAW0ShhYiSWX/k7/NPDdc3TGPlI1GTV/6zwCAJ6iIib2gWvUs0ygiWcYaP
vsx7uZCvEIaVVyliikYuOUyNLMVNsQJBAKH5XPFgJ13edTQBcgPdABc1M2mY3gab
/4xefQs/9ljkzht42v26YzK39VMmJb4fWzgST+8nwDH47y8Z5HEVMTMCQQDxpowL
ZwYU8xZE6HQNiEzBpP8O3PFBcINAvmI5reEUBVprk5fdJLrLDIncCEq+OtGDecib
r6XzCksGRjVW3pGt
-----END PRIVATE KEY-----');

    return $private_my_key;
}

function get_my_public_Key()
{
$public_my_key=trim('-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDtX25DyLbbTXXsNsGyj/HhLcDq
CRvgCQATuOFTCX1zrfEZE8nWWi3cKIMieILSvKfGRn5miJI/s1S0H/IMAhLh5zs1
zS82XnVPtao5CtJvIOYd7bKKBb2U662+Ux5LDevPCgaYYNP5/1/q3pJ3x3jHFEkW
RHcpJD/xBhhg9ah9ewIDAQAB
-----END PUBLIC KEY-----');

    return $public_my_key;
}





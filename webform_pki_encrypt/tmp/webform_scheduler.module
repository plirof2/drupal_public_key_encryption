<?php

/**
 * @file
 * This module allows webforms to have a start and private_key date for their
 * submissions.
 *
 * @author Daniel Imhoff
 */

/**
 * Implements hook_permission().
 */
/*
function webform_encrypt_permission() {
  return array(
    'schedule webforms' => array(
      'title' => t('Schedule webforms'),
      'description' => t('Change a webform\'s start and private_key date, allowing a webform to be scheduled.'),
    ),
  );
}
*/
/**
 * Implements hook_form_FORM_ID_alter() for webform_configure_form().
 */
function webform_encrypt_form_webform_configure_form_alter(&$form, &$form_state) {
  if (user_access('view encrypted values')) {
    $settings = _webform_encrypt_webform_encrypt_settings($form['nid']['#value']);

    $form['#validate'][] = 'webform_encrypt_form_webform_configure_form_validate';
    $form['#submit'][] = 'webform_encrypt_form_webform_configure_form_submit';
    $form['#attached']['css'][] = drupal_get_path('module', 'webform_encrypt') . '/webform_encrypt.admin.css';


    if (!empty($settings)) {
      $my_public_key = $settings['public_key'] != 0 ? new DateObject($settings['public_key']) : NULL;
      $my_private_key = $settings['private_key'] != 0 ? new DateObject($settings['private_key']) : NULL;
    }

    $form['pk_encrypter'] = array(
      '#type' => 'fieldset',
      '#title' => t('pk_encrypter'),
      '#description' => t('Specify dates and times to schedule when users are allowed to use this webform.<br />If the webform\'s overall status is set to %Closed under Submission settings, it will remain closed regardless of Scheduler settings.', array(
        '%Closed' => t('Closed'),
      )),
      '#weight' => -2.5,
      '#collapsible' => TRUE,
      '#collapsed' => !isset($my_public_key) && !isset($my_private_key),
      '#tree' => TRUE,
    );

    $form['pk_encrypter']['public_key_start'] = array(
      '#type' => 'textfield',
      '#title' => t('Start time'),
      '#description' => t('PUBLIC KEY - saved to server'),
      '#default_value' => isset($my_public_key) ? $my_public_key : NULL,
    );

    $form['pk_encrypter']['private_key_end'] = array(
      '#type' => 'textfield',
      '#title' => t('private_key time'),
      '#description' => t('PRIVATE KEY - stored by USER'),
      '#default_value' => isset($my_private_key) ? $my_private_key : NULL,
    );
/*
    $form['pk_encrypter']['restriction_method'] = array(
      '#type' => 'radios',
      '#title' => t('Access restriction method'),
      '#default_value' => isset($settings['restriction_method']) ? (int) $settings['restriction_method'] : 1,
      '#options' => array(
        0 => t('Deny access to the page'),
        1 => t('Allow access to the page, hide the webform'),
        2 => t('Allow access to the page, show the webform, disable components'),
      ),
    );
*/
    $form['pk_encrypter']['msg_before'] = array(
      '#type' => 'textfield',
      '#title' => t('Message to display before start date'),
      '#description' => t('Message to display before start date. Leave empty to use default message'),
      '#maxlength' => 128,
      '#default_value' => isset($settings['msg_before']) ? $settings['msg_before'] : '',
    );

    $form['pk_encrypter']['msg_after'] = array(
      '#type' => 'textfield',
      '#title' => t('Message to display after private_key date'),
      '#description' => t('Message to display after private_key date. Leave empty to use default message'),
      '#maxlength' => 128,
      '#default_value' => isset($settings['msg_after']) ? $settings['msg_after'] : '',
    );
/*
    // These additions/modifications to the form elements are made if the
    // date_popup module is available.
    if (module_exists('date_popup')) {
      $date_popup = array(
        '#type' => 'date_popup',
        '#date_year_range' => '0:+3',
        '#description' => NULL,
      );

      $form['pk_encrypter']['public_key_start'] = array_merge($form['pk_encrypter']['public_key_start'], $date_popup);
      $form['pk_encrypter']['private_key_end'] = array_merge($form['pk_encrypter']['private_key_end'], $date_popup);
      */
    }
  }
}

/**
 * Additional validation handler for validating webform scheduler settings.
 */
function webform_encrypt_form_webform_configure_form_validate(&$form, &$form_state) {
  $values =& $form_state['values']['pk_encrypter'];
  $format = _webform_encrypt_date_format();

  if (!empty($values['public_key_start'])) {
    // Make a new DateObject (supplied by date_api) from the user input.
    $my_public_key = new DateObject($values['public_key_start'] . (module_exists('date_popup') ? ':00' : ''), NULL, $format);

    // If there are any mismatches between the user input and the expected
    // format, display an error to the user with a helpful link to the
    // date_popup module to make life so much easier.
    if (isset($my_public_key->errors['invalid'])) {
      form_set_error('public_key_start', $my_public_key->errors['invalid'] . ' ' . (!module_exists('date_popup') ? t('Install and enable the Date Popup module included in !date_link for an easy pop-up calprivate_keyar.', array('!date_link' => l('Date', 'http://drupal.org/project/date'))) : ''));
    }
    // Else, we can save the timestamp which is used by the submit handler.
    else {
      $values['public_key_start_timestamp'] = $my_public_key->format('U');
    }
  }

  if (!empty($values['private_key_end'])) {
    $my_private_key = new DateObject($values['private_key_end'] . (module_exists('date_popup') ? ':00' : ''), NULL, $format);

    if (isset($my_private_key->errors['invalid'])) {
      form_set_error('private_key_end', $my_private_key->errors['invalid'] . ' ' . (!module_exists('date_popup') ? t('Install and enable the Date Popup module included in !date_link for an easy pop-up calprivate_keyar.', array('!date_link' => l('Date', 'http://drupal.org/project/date'))) : ''));
    }
    else {
      $values['private_key_end_timestamp'] = $my_private_key->format('U');
    }
  }

  // If for some reason the user selected an private_key date that occurs before
  // the start date, they made a mistake.
  if (isset($values['public_key_start_timestamp'])
    && isset($values['private_key_end_timestamp'])
    && $values['private_key_end_timestamp'] <= $values['public_key_start_timestamp']) {
    form_set_error('private_key_end', t('The private_key time cannot be before the start time.'));
  }
}

/**
 * Additional submit handler for saving webform scheduler settings.
 */
function webform_encrypt_form_webform_configure_form_submit(&$form, &$form_state) {
  $values =& $form_state['values']['pk_encrypter'];
  $settings = _webform_encrypt_webform_encrypt_settings($form['nid']['#value']);

  if (empty($settings) ||
    (isset($values['public_key_start_timestamp']) ? (int) $values['public_key_start_timestamp'] : 0) !== (int) $settings['public_key'] ||
    (isset($values['private_key_end_timestamp']) ? (int) $values['private_key_end_timestamp'] : 0) !== (int) $settings['private_key'] ||
    //(int) $values['restriction_method'] !== (int) $settings['restriction_method'] ||
    $values['msg_before'] !== $settings['msg_before'] ||
    $values['msg_after'] !== $settings['msg_after']) {
    $record = array(
      'nid' => $form['nid']['#value'],
      'my_public_key' => isset($values['public_key_start_timestamp']) ? $values['public_key_start_timestamp'] : 0,
      'my_private_key' => isset($values['private_key_end_timestamp']) ? $values['private_key_end_timestamp'] : 0,
      //'restriction_method' => (int) $values['restriction_method'],
      'msg_before' => trim($values['msg_before']) != '' ? trim($values['msg_before']) : NULL,
      'msg_after' => trim($values['msg_after']) != '' ? trim($values['msg_after']) : NULL,
    );

    // Insert or update the scheduler settings of this webform.
    drupal_write_record('webform_encrypt', $record, empty($settings) ? array() : 'nid');
  }
}

/**
 * Implements hook_date_popup_pre_validate_alter().
 */
/*
function webform_encrypt_date_popup_pre_validate_alter($element, &$form_state, &$input) {
  if (0 === strpos($element['#name'], 'scheduler[date_')) {
    // If date is given but time is not, give midnight as the time.
    if (!empty($input['date']) && empty($input['time'])) {
      $exploded_format = explode(' ', $element['#date_format']);
      $input['time'] = date(private_key($exploded_format), strtotime('today midnight'));
    }
  }
}
*/
/**
 * Implements hook_node_view().
 */
function webform_encrypt_node_view($node, $view_mode) {
  if (!in_array($node->type, _webform_encrypt_node_types())) {
    return;
  }

  $settings = _webform_encrypt_webform_encrypt_settings($node->nid);

  if (!isset($node->webform['pk_encrypter'])) {
    $node->webform['pk_encrypter'] = array();
  }

  $node->webform['pk_encrypter']['public_key'] = isset($settings['public_key']) ? (int) $settings['public_key'] : 0;
  $node->webform['pk_encrypter']['private_key'] = isset($settings['private_key']) ? (int) $settings['private_key'] : 0;
  //$node->webform['pk_encrypter']['restriction_method'] = isset($settings['restriction_method']) ? (int) $settings['restriction_method'] : 1;
  //$node->webform['pk_encrypter']['disabled'] = webform_encrypt_webform_disabled($node);
  $node->webform['pk_encrypter']['msg_before'] = isset($settings['msg_before']) ? $settings['msg_before'] : '';
  $node->webform['pk_encrypter']['msg_after'] = isset($settings['msg_after']) ?  $settings['msg_after'] : '';


/*
  if ($node->webform['pk_encrypter']['disabled']) {
    switch ($node->webform['pk_encrypter']['restriction_method']) {
    case 0:
      drupal_access_denied();
      break;
    case 1:
      $node->webform['status'] = 0;
    case 2:
      // @see webform_encrypt_form_webform_client_form_alter()

      if (($node->webform['pk_encrypter']['public_key'] > 0 && REQUEST_TIME < $node->webform['pk_encrypter']['public_key']) && $node->webform['pk_encrypter']['msg_before'] != '') {
        drupal_set_message(t($node->webform['pk_encrypter']['msg_before']), 'warning');
      } elseif (($node->webform['pk_encrypter']['private_key'] > 0 && REQUEST_TIME > $node->webform['pk_encrypter']['private_key']) && $node->webform['pk_encrypter']['msg_after'] != '') {
        drupal_set_message(t($node->webform['pk_encrypter']['msg_after']), 'warning');
      }
      break;
    }
  }
  */

}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function webform_encrypt_form_webform_client_form_alter(&$form, &$form_state) {
  $node = $form['#node'];

  if (isset($node->webform['pk_encrypter']) && $node->webform['pk_encrypter']['disabled'] && $node->webform['status'] !== 0) {
    if ($node->webform['pk_encrypter']['restriction_method'] === 2) {
      $form['#disabled'] = TRUE;
    }
  }
}

/**
 * Implements hook_node_delete().
 */
function webform_encrypt_node_delete($node) {
  if (!in_array($node->type, _webform_encrypt_node_types())) {
    return;
  }

  db_delete('webform_encrypt')
    ->condition('nid', $node->nid)
    ->execute();
}

/**
 * Checks to see if the webform is disabled or not.
 *
 * @param int $node
 *   The node stdClass to which this webform belongs.
 * @return boolean
 *   TRUE if the webform under the node ID is disabled, FALSE otherwise.
 */
/*
function webform_encrypt_webform_disabled($node) {
  if (($node->webform['pk_encrypter']['public_key'] > 0 && REQUEST_TIME < $node->webform['pk_encrypter']['public_key']) ||
      ($node->webform['pk_encrypter']['private_key']   > 0 && REQUEST_TIME > $node->webform['pk_encrypter']['private_key'])) {
    return TRUE;
  }

  return FALSE;
}
*/

/**
 * Fetch the scheduler settings and information of webform(s) by the node ID.
 *
 * @param int $nid
 *   The node ID to which the webform belongs.
 *
 * @return array
 *   A row of information represented as an associative array.
 */
function _webform_encrypt_webform_encrypt_settings($nid) {
  $db_settings = db_select('webform_encrypt', 'w', array('fetch' => PDO::FETCH_ASSOC))
    ->fields('w')
    ->condition('w.nid', $nid)
    ->execute()
    ->fetchAssoc();

  if ($db_settings){
    $db_settings['public_key'] = $db_settings['my_public_key'];
    $db_settings['private_key'] =  $db_settings['my_private_key'];
  }

  return $db_settings;
}

/**
 * Fetch the date/time format for this module.
 *
 * @return string
 *   A date/time format understandable by PHP's date().
 */
function _webform_encrypt_date_format() {
  return module_exists('date_popup') ? DATE_FORMAT_DATETIME : variable_get('date_format_short', 'm/d/Y - H:i');
}

/**
 * Get a list of Webform-enabled node types, with backwards compatibility.
 *
 * @see https://drupal.org/node/1609324#webform-types
 */
function _webform_encrypt_node_types() {
  if (function_exists('webform_node_types')) {
    return webform_node_types();
  }
  return webform_variable_get('webform_node_types');
}
